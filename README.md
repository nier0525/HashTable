# HashTable

C++ 로 구현한 해쉬 테이블 입니다.
Template 를 활용하여 Key 는 정수, 실수, 문자, 문자열 만 받을 수 있도록 설계 하였고 Value 는 어떤 타입이든 받을 수 있게 설계하였습니다.  
  
O(1) 을 지향하고자 하였으나, 테이블 크기에 따라 Key 중복이 아니더라도 같은 공간에 들어가는 상황도 충분히 발생할 수 있는 코드입니다.  
그런 경우를 대비해 이분탐색 알고리즘을 활용하여 최악의 경우에도 O(log n) 이 되도록 설계하였습니다.  
  
  
![image](https://user-images.githubusercontent.com/63215359/106380973-16798000-63f9-11eb-9cd5-6ae804bfdbc1.png)  
  
가령 위 그림처럼 테이블 크기가 3 이고 Key 값을 넣는다고 가정해보자
  
![image](https://user-images.githubusercontent.com/63215359/106381026-648e8380-63f9-11eb-845f-56944c106a90.png)  
  
Key 값이 3 개가 들어간 후 나머지 1 개는 필연적으로 이미 Key 값이 한 개가 들어가 있는 자리에 들어갈 수 밖에 없게 된다.  
물론 들어 갈 자리가 있더라도 해쉬값으로 구한 Key 값의 자리가 동일해지면 역시 같은 자리에 들어가게 된다.  
  
![image](https://user-images.githubusercontent.com/63215359/106381085-d8c92700-63f9-11eb-89c0-c8e6364a6b28.png)  
  
최종적으로 이런 모양으로 Key 값이 모두 테이블에 들어 갈 것이다.  
이런 상황에서는 O(1) 이 될 수 없고 이후에 이런 상황에 계속 발생하면 결국 데이터를 찾는데 많은 시간이 소요될 것이다.  
이 문제를 해결하기 위해서 이분탐색 알고리즘을 사용하였다.  
  
![image](https://user-images.githubusercontent.com/63215359/106381191-6ad12f80-63fa-11eb-87f1-1ad01764834a.png)  
  
데이터를 찾기 위해 순회를 시작할 떄 처음 피벗의 위치는 배열의 정중앙이다.  
  
![image](https://user-images.githubusercontent.com/63215359/106381262-dddaa600-63fa-11eb-97e7-54fa75486d91.png)  
  
현재 피벗 위치의 데이터보다 찾는 데이터가 클 경우 오른쪽, 작을 경우 왼쪽으로 피벗을 이동시킨다.  
이 때, 이동 할 피벗의 위치는 각 방향의 끝과 현재 위치의 중간이 된다.  
  
![image](https://user-images.githubusercontent.com/63215359/106381347-6fe2ae80-63fb-11eb-99f4-c617318ce619.png)  
  
이 흐름으로 데이터를 찾을 때까지 반복한다.  
크기가 100 이고 순차적으로 1~100 까지 데이터가 들어가 있는 배열로 시험한 결과 81 이라는 값을 찾는데 3 회가 걸리는 것을 확인할 수 있었다.  
  
  
사실 최적의 상황은 어떤 상황에서든 O(1) 가 나오는 상황이지만 미숙한 실력으로 인해 아직도 하루 종일 머리를 부여잡으며 방법을 생각하고 있다..  
    
